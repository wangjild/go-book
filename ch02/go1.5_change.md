### go1.5编译过程的变革
go1.4及其之前的版本，使用的编译工具链继承自Plan 9，大部分是c语言编写的。这套工具链位于src/cmd下面，分别是5a, 5c, 5g, 5l, 6a, 6c, 6c, 6g, 6l, 8a, 8c, 8g, 8l 和 cc, gc

其中数字代表的编译目标的体系结构，5代表arm，6代表x86-64，8代表x86; 字母代表编译工具的类别，a代表汇编语言编译器，l代表链接器，c代表c语言编译器，g代表go语言编译器; 而cc和gc则是和体系结构无关的通用c编译器和go编译器

这么做是由于go还没有被构建出来，因此编译工具必须基于其他语言来编写，而采用已有的工具链(plan 9)会非常方便。

go1.5将大部分编译工具链用go重写过，所以go1.5的编译过程就有点自举的味道了。这是一个鸡生蛋，蛋生鸡的过程。大体的编译过程如下：
> 1. 使用go1.4编译cmd/dist(1.4)工具
> 2. 使用cmd/dist(1.4)配合go1.4编译go1.5的编译器工具链
> 3. 使用go1.5的编译工具链编译cmd/dist(1.5)
> 4. 使用cmd/dist(1.5)和go1.5的编译器工具链编译go_bootstrap(1.5)
> 5. 使用go_bootstrap(1.5)来编译go1.5的标准库和其他命令集

至于为什么这样做，在这篇文章中go的作者们做出了解释：
> 1. 编写正确的go语言比编写正确的c语言容易
> 2. debug go语言比debug c语言容易
> 3. 使用go来编写go编译器要求对go语言本身有深刻理解，单不要求对c语言有深刻理解
> 4. go有着更高层抽象的并发
> 5. go比c有更好的模块化，自动重新，单元测试和profiling支持
> 6. go用起来比c更为有趣
